1. C++: Encapsulation, Inheritance and Polymorphism

Inheritance: construction, access level, multiple inheritance

1) public继承方式
基类中所有 public 成员在派生类中为 public 属性；
基类中所有 protected 成员在派生类中为 protected 属性；
基类中所有 private 成员在派生类中不能使用。

2) protected继承方式
基类中的所有 public 成员在派生类中为 protected 属性；
基类中的所有 protected 成员在派生类中为 protected 属性；
基类中的所有 private 成员在派生类中不能使用。

3) private继承方式
基类中的所有 public 成员在派生类中均为 private 属性；
基类中的所有 protected 成员在派生类中均为 private 属性；
基类中的所有 private 成员在派生类中不能使用。

https://blog.csdn.net/feiyinzilgd/article/details/6226348

The protected access label can be thought of as a blend of private and public :

Like private members, protected members are inaccessible to users of the class.
Like public members, the protected members are accessible to classes derived from this class.
In addition, protected has another important property:
A derived object may access the protected members of its base class only through a derived
object. The derived class has no special access to the protected members of base type objects.

在没有继承的情况下，protected跟private相同。在派生类的时候才出现分化。

上面那段英文前两条都很好理解，基类对象不能访问基类的protected成员，派生类中可以访问基类的protected成员。
也就是说private成员是不能被继承的，只有public，protected的成员才可以被继承。

很多书上都说有派生类的情况下protected的访问权限同public。这种说法是不对的，类内部直接访问没什么区别，
但是访问对象基类的protected成员只能是在该类的内部。


Polymorphism: 
https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/
https://blog.csdn.net/i_chaoren/article/details/77281785

Array -> Actual Object (vptr) -> VTable

vptr: A pointer to vtable. It is maintained per object
vtable: A table of function pointers. It is maintained per class



2. 3 different ways to create array of strings in C++

reference: https://www.geeksforgeeks.org/array-strings-c-3-different-ways-create/


1) char colour[4][10] = {"Blue", "Red", "Orange", "Yellow"};
2) string colour[4] = {"Blue", "Red", "Orange", "Yellow"};
3) vector<string> colour;
   colour.push_back("Blue");
   colour.push_back("Red");
   colour.push_back("Orange");
   colour.push_back("Yellow");

tips:
g++ Strings.cpp -o Strings
effective STL


3. String Summary

http://www.cplusplus.com/reference/string/string/


4. read input array

fixed number:
int main()
{
       int n = 0;
       cin >> n;
       vector<int> p(n);
       for(int i = 0; i < n; i++){
              cin >> p[i];
       }
       return 0;
}


variable number:
#include<sstream> //注意加这个头
int main()
{
       string str,temp;
       getline(cin, str);
       int i = 0;
       vector<int> p;
       stringstream input(str);
       while(input >> i){
              p.push_back(i);
       }      
       return 0;
}

vector print:
for (auto iter = p.begin(); iter != p.end(); iter++){
    cout << *iter << ' ';
}


5. STL: Vector

1) Declaration:
vector<int>v; (creates an empty vector of integers)

2) Size:
int size=v.size();

3) Pushing an integer into a vector:
v.push_back(x);(where x is an integer.The size increases by 1 after this.)

4) Popping the last element from the vector:
v.pop_back(); (After this the size decreases by 1)

5) Sorting a vector:
sort(v.begin(),v.end()); (Will sort all the elements in the vector)

6) erase(int position):
Removes the element present at position.  
Ex: v.erase(v.begin()+4); (erases the fifth element of the vector v)
erase(int start,int end):

Removes the elements in the range from start to end inclusive of the start and exclusive of the end.
Ex:v.erase(v.begin()+2,v.begin()+5);(erases all the elements from the third element to the fifth element.)

tips 
correct:
int p1,p2,p3;
int p1=0,p2=0,p3=0; 
int p1,p2=0,p3=0;

wrong:
int p1=p2=p3=0;


6. STL: Map

1）Map Template:
std::map <key_type, data_type>

2）Declaration:
map<string,int>m; //Creates a map m where key_type is of type string and data_type is of type int.

3）Size:
int length=m.size(); //Gives the size of the map.

4）Insert:
m.insert(make_pair("hello",9)); //Here the pair is inserted into the map where the key is "hello" and the value associated with it is 9.

5）Erasing an element:
m.erase(val); //Erases the pair from the map where the key_type is val.

6）Finding an element:
map<string,int>::iterator itr=m.find(val); //Gives the iterator to the element val if it is found otherwise returns m.end() .
Ex: map<string,int>::iterator itr=m.find("Maps"); //If Maps is not present as the key value then itr==m.end().

7）Accessing the value stored in the key:
To get the value stored of the key "MAPS" we can do m["MAPS"] or we can get the iterator using the find function and then by itr->second we can access the value.



7. STL: Set
Sets are a part of the C++ STL. Sets are containers that store unique elements following a specific order. Here are some of the frequently used member functions of sets:

1) Declaration:
set<int>s; //Creates a set of integers.

2) Size:
int length=s.size(); //Gives the size of the set.

3) Insert:
s.insert(x); //Inserts an integer x into the set s.

4) Erasing an element:
s.erase(val); //Erases an integer val from the set s.

5) Finding an element:
set<int>::iterator itr=s.find(val); //Gives the iterator to the element val if it is found otherwise returns s.end() .
Ex: set<int>::iterator itr=s.find(100); //If 100 is not present then it==s.end().



8. STL: Deque

Double ended queue or Deque(part of C++ STL) are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back). The member functions of deque that are mainly used are:

1) Deque Template:
std::deque<value_type>

2) Declaration:
deque<int> mydeque; //Creates a double ended queue of deque of int type

3) Size
int length = mydeque.size(); //Gives the size of the deque

4) Push
mydeque.push_back(1); //Pushes element at the end
mydeque.push_front(2); //Pushes element at the beginning

5) Pop
mydeque.pop_back(); //Pops element from the end
mydeque.pop_front(); //Pops element from the beginning

6) Empty
mydeque.empty() //Returns a boolean value which tells whether the deque is empty or not


tips:
lower_bound & upper_bound

iterator lower_bound( const key_type &key ): 返回一个迭代器，指向键值>= key的第一个元素。

iterator upper_bound( const key_type &key ):返回一个迭代器，指向键值> key的第一个元素。

9. C++ formating output:

#include <iostream>
#include <iomanip>//不要忘记包含此头文件
using namespace std;
int main()
{
   int a;
   cout<<"input a:";
   cin>>a;
   cout<<"dec:"<<dec<<a<<endl;  //以十进制形式输出整数
   cout<<"hex:"<<hex<<a<<endl;  //以十六进制形式输出整数a
   cout<<"oct:"<<setbase(8)<<a<<endl;  //以八进制形式输出整数a
   char *pt="China";  //pt指向字符串"China"
   cout<<setw(10)<<pt<<endl;  //指定域宽为,输出字符串
   cout<<setfill('*')<<setw(10)<<pt<<endl;  //指定域宽,输出字符串,空白处以'*'填充
   double pi=22.0/7.0;  //计算pi值
   //按指数形式输出,8位小数
   cout<<setiosflags(ios::scientific)<<setprecision(8);
   cout<<"pi="<<pi<<endl;  //输出pi值
   cout<<"pi="<<setprecision(4)<<pi<<endl;  //改为位小数
   cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl;  //改为小数形式输出
   return 0;
}

https://www.cnblogs.com/yongdaimi/p/7126409.
refer to print pretty file.




